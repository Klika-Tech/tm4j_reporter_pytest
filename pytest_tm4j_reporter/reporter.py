import re
from copy import deepcopy

import pytest
from pytest_jsonreport.plugin import JSONReport


class TM4JReporter:
    def __init__(self, config=None):
        self._config = config
        # should be read from pytest.ini and use <prj_key>-T instead of T
        self.prefix_test = 'T'
        self.prefix_prj = None
        self.api_key = None
        self.testplan_id = None

    def pytest_configure(self, config):
        if not hasattr(config, '_tm4j_report'):
            self._config._tm4j_report = self

        # Activate json-report plugin for report generation
        Plugin = JSONReport
        plugin = Plugin(config)
        config._json_report = plugin
        config.pluginmanager.register(plugin)

        self.prefix_prj = config.getini('tm4j_project_prefix')
        self.api_key = config.getini('tm4j_api_key')
        self.testplan_id = config.getini('tm4j_testplan_id')

    def pytest_json_modifyreport(self, json_report: dict):
        """
        The hook belongs to json-report plugin
        Rewrites an original report
        """
        json_report_orig = deepcopy(json_report)
        for key in json_report_orig.keys():
            del json_report[key]
        json_report['tests'] = self.prepare_tm4j_report_json(json_report_orig)

    @staticmethod
    def pytest_json_runtest_metadata(item, call) -> dict:
        """
        The hook belongs to json-report plugin
        Reads the metadata from the test body and writes it to the report
        """
        if call.when == 'teardown':
            result = {'steps': item.meta_steps, 'summary': item.meta_summary}
            return result

    @staticmethod
    @pytest.fixture
    def tm4j_r(request):
        """
        TM4J-related metadata can be added to test using MetaHolder class

        def test_T303_one(tm4j_r):
            tm4j_r.summary = 'test one summary'
            tm4j_r.step('test one step A')
            tm4j_r.step('test one step B')
        """

        class MetaHolder:
            def __init__(self):
                self.steps = []
                self.summary = None

            def step(self, text: str):
                self.steps.append(text)

        m = MetaHolder()
        yield m
        request.node.meta_steps = m.steps
        request.node.meta_summary = m.summary
        return m

    @staticmethod
    def _resolve_outcome(outcome: str) -> str:
        """
        Map pytest test outcome to tm4j outcome
        """
        # A key is for pytest, value is for TM4J
        outcomes = {
            'passed': 'Pass',
            'failed': 'Fail'}
        return outcomes[outcome]

    def prepare_tm4j_report_json(self, pytest_json: dict) -> dict:
        """
        Prepares the data for report
        Example output:

        {'T303': {'name': 'one', 'outcome': 'Pass',
                  'steps': ['test one step A', 'test one step B'],
                  'summary': 'test one summary'},
         'T304': {'name': 'two', 'outcome': 'Pass',
                  'steps': ['test two step A', 'test two step B'],
                  'summary': 'test two summary'}}

        :type pytest_json: dict generated by the json-report plugin
        """
        report = pytest_json
        results = {}
        tests_wo_tm4j_id = []

        for test_dict in report['tests']:
            test_name_full = test_dict['nodeid']
            # test_common.py::test_T303_one
            test_name_wo_module = test_name_full.split('::')[-1]
            # test_T303_one

            tm4j_num_ptrn = f'{self.prefix_test}\d+'
            t_name_ptrn = '.*'
            is_test_valid_tm4j = re.match(
                f'^.*_({tm4j_num_ptrn})_({t_name_ptrn})', test_name_wo_module)
            if not is_test_valid_tm4j:
                tests_wo_tm4j_id.append(test_name_full)
                continue
            tm4j_num = is_test_valid_tm4j.group(1)
            test_name = is_test_valid_tm4j.group(2)

            results[tm4j_num] = {
                'name': test_name,
                'outcome': self._resolve_outcome(test_dict['outcome'])}
            results[tm4j_num].update(test_dict['metadata'])

        if tests_wo_tm4j_id:
            print(f"\n\nWARNING: some test results cannot be exported to TM4J "
                  f"because they don't have a TM4J test ID in their name."
                  f"\nexample: \"test_{self.prefix_test}123_testname\" "
                  f"where {self.prefix_test}123 is a TM4J test ID"
                  f"\ntests affected: {' '.join(tests_wo_tm4j_id)}")

        return results


def pytest_addoption(parser):
    group = parser.getgroup('tm4j', 'reporting test results to TM4J')
    group.addoption(
        '--tm4j', default=False, action='store_true',
        help='report test results to TM4J')

    parser.addini('tm4j_project_prefix', 'TM4J project prefix')
    parser.addini('tm4j_api_key', 'TM4J API key')
    parser.addini('tm4j_testplan_id', 'TM4J test plan ID')


def pytest_configure(config):
    # Activates the plugin if a --tm4j flag passed to pytest cmdline
    if not config.option.tm4j:
        return
    Plugin = TM4JReporter
    plugin = Plugin(config)
    config._tm4j_report = plugin
    config.pluginmanager.register(plugin)
